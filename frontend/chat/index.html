<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chat • OpenRouter</title>
  <style>
    :root {
      --bg: #0f1226;
      --panel: #15193a;
      --panel-2: #1a1f4d;
      --text: #e6e8ff;
      --muted: #9aa3ff;
      --accent: #7c8aff;
      --accent-2: #9f7aea;
      --danger: #ff6b6b;
      --good: #35d07f;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; padding: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 20% -10%, #1c2255 0%, transparent 60%),
                  radial-gradient(1000px 600px at 120% 10%, #3a1d5d 0%, transparent 60%),
                  var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    header {
      position: sticky; top: 0; z-index: 10;
      backdrop-filter: blur(8px);
      background: rgba(10, 12, 30, 0.6);
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }
    .nav {
      max-width: 900px; margin: 0 auto; padding: 14px 16px;
      display: flex; align-items: center; gap: 12px; justify-content: space-between;
    }
    .nav a { color: var(--muted); text-decoration: none; }
    .status {
      display: flex; align-items: center; gap: 8px; color: var(--muted); font-size: 13px;
    }
    .dot { width: 8px; height: 8px; border-radius: 50%; background: #888; box-shadow: 0 0 8px rgba(255,255,255,0.1); }
    .dot.ok { background: var(--good); box-shadow: 0 0 10px rgba(53,208,127,0.6); }
    .dot.err { background: var(--danger); box-shadow: 0 0 10px rgba(255,107,107,0.6); }

    .wrap { max-width: 1200px; margin: 0 auto; width: 100%; flex: 1; display: flex; flex-direction: column; }
    .messages { flex: 1; padding: 20px 16px 120px; overflow-y: auto; }
    .msg { display: flex; gap: 12px; margin: 12px 0; }
    .avatar { width: 32px; height: 32px; border-radius: 6px; background: var(--panel-2); display: grid; place-items: center; font-weight: 700; color: var(--muted); }
    .bubble { max-width: 80%; padding: 12px 14px; border-radius: 12px; line-height: 1.45; }
    .user .bubble { background: #24306b; border: 1px solid rgba(255,255,255,0.08); }
    .assistant .bubble { background: var(--panel); border: 1px solid rgba(255,255,255,0.06); }
    .assistant .avatar { background: linear-gradient(135deg, var(--accent), var(--accent-2)); color: white; }
    .msg pre { margin: 0; white-space: pre-wrap; word-wrap: break-word; }
    details summary { cursor: pointer; color: var(--muted); }
    details pre { margin-top: 6px; opacity: 0.95; }
    /* Render thinking content in grey for readability */
    details[data-thinking] pre { color: #b8bfd6; }

    .composer {
      position: fixed; bottom: 0; left: 0; right: 0; padding: 12px 16px;
      background: linear-gradient(180deg, rgba(10,12,30,0) 0%, rgba(10,12,30,0.7) 30%, rgba(10,12,30,0.9) 100%);
    }
    .composer .inner { max-width: 900px; margin: 0 auto; background: var(--panel); border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 10px; display: flex; gap: 10px; }
    .composer textarea { flex: 1; background: transparent; border: none; color: var(--text); resize: none; min-height: 44px; max-height: 160px; outline: none; font-size: 15px; }
    .composer button { background: linear-gradient(135deg, var(--accent), var(--accent-2)); color: white; border: none; padding: 10px 16px; border-radius: 10px; cursor: pointer; font-weight: 600; }
    .composer button:disabled { opacity: 0.6; cursor: not-allowed; }
    .toolbar { display: flex; gap: 8px; align-items: center; color: var(--muted); font-size: 12px; margin-top: 6px; }
    .link { color: var(--accent); text-decoration: none; }
    .status .sep { opacity: 0.6; }

    /* Layout with collapsible sidebar */
    .layout { display: grid; grid-template-columns: 260px 1fr; gap: 0; min-height: calc(100vh - 60px); }
    .layout.sidebar-collapsed { grid-template-columns: 0 1fr; }
    .sidebar { overflow: hidden; border-right: 1px solid rgba(255,255,255,0.08); background: rgba(10, 12, 30, 0.3); }
    .sidebar .head { padding: 10px; border-bottom: 1px solid rgba(255,255,255,0.06); display:flex; gap:8px; align-items:center; }
    .sidebar .head button { background: var(--panel-2); color: var(--text); border: 1px solid rgba(255,255,255,0.12); padding: 8px 10px; border-radius:8px; cursor:pointer; font-weight:600; }
    .sidebar .list { overflow:auto; max-height: calc(100vh - 160px); }
    .item { padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.06); cursor:pointer; display:flex; align-items:center; justify-content:space-between; gap:8px; }
    .item:hover { background: #1a1f4d; }
    .item.active { background: linear-gradient(135deg, rgba(124,138,255,0.2), rgba(159,122,234,0.15)); border-left: 3px solid var(--accent); }
    .item .name { font-size: 13px; color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .item .meta { font-size: 11px; color: var(--muted); opacity: 0.9; }
    .item .actions { display:flex; gap:6px; }
    .item .actions a { color: var(--muted); font-size: 12px; text-decoration:none; }
    .content { display:flex; flex-direction:column; }
    .toggle-btn { background: var(--panel-2); color: var(--text); border: 1px solid rgba(255,255,255,0.12); padding: 6px 10px; border-radius:8px; cursor:pointer; font-weight:600; }
  </style>
  <script>
    const currentSessionKey = 'chat_current_session_id_v1';
    const thinkingPrefKey = 'chat_thinking_open_v1';
    const sidebarOpenKey = 'chat_sidebar_open_v1';
    const localNamesKey = 'chat_session_names_v1';

    let currentSessionId = null; // Lazily created on first send if needed
    let allSessions = []; // from backend
    let localNames = {};

    try { const saved = JSON.parse(localStorage.getItem(localNamesKey) || '{}'); if (saved && typeof saved === 'object') localNames = saved; } catch {}
    // Intentionally do not auto-restore prior session id: default to a new session until first send

    function setCurrentSessionId(id) {
      currentSessionId = id || null;
      try { if (id) localStorage.setItem(currentSessionKey, id); else localStorage.removeItem(currentSessionKey); } catch {}
      updateSessionLabel();
      renderSessionList();
    }

    function ensureSessionId() {
      if (!currentSessionId) {
        const id = (self.crypto?.randomUUID?.() || Math.random().toString(36).slice(2));
        setCurrentSessionId(id);
      }
      return currentSessionId;
    }

    function nameFor(id) {
      const server = allSessions.find(s => s.session_id === id);
      return (server && server.name) || localNames[id] || null;
    }

    function saveLocalNames() {
      try { localStorage.setItem(localNamesKey, JSON.stringify(localNames)); } catch {}
    }

    // Persisted user preference: whether "Thinking…" is expanded
    let thinkingOpenPref = false;
    try { thinkingOpenPref = JSON.parse(localStorage.getItem(thinkingPrefKey) || 'false'); } catch {}
    function setThinkingOpen(v) {
      thinkingOpenPref = !!v;
      try { localStorage.setItem(thinkingPrefKey, JSON.stringify(thinkingOpenPref)); } catch {}
    }

    let messages = [];
    let isLoadingLogs = false;
    function addMessage(role, content) {
      messages.push({ role, content });
      renderMessages();
    }

    // Update time display
    function updateTime() {
      const el = document.getElementById('timeText');
      if (!el) return;
      const now = new Date();
      const timeString = now.toLocaleTimeString('en-US', {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
      });
      el.textContent = timeString;
    }

    function renderMessages() {
      const list = document.getElementById('messages');
      list.innerHTML = '';
      messages.forEach(m => {
        const item = document.createElement('div');
        item.className = `msg ${m.role}`;
        const avatar = document.createElement('div');
        avatar.className = 'avatar';
        avatar.textContent = m.role === 'user' ? 'U' : 'A';
        const bubble = document.createElement('div');
        bubble.className = 'bubble';
        // Thinking block: always on top when enabled, toggle show/hide via <details>
        if (m.role === 'assistant' && m.thinking_enabled) {
          if (typeof m.thinking_open !== 'boolean') { m.thinking_open = thinkingOpenPref; }
          const details = document.createElement('details');
          details.setAttribute('data-thinking', '1');
          details.style.marginBottom = '8px';
          const summary = document.createElement('summary');
          summary.textContent = 'Thinking…';
          const thinkPre = document.createElement('pre');
          thinkPre.textContent = (m.thinking && m.thinking.length) ? m.thinking : '';
          const shouldOpen = (typeof m.thinking_open === 'boolean') ? m.thinking_open : thinkingOpenPref;
          if (shouldOpen) details.setAttribute('open', 'open');
          details.addEventListener('toggle', () => { m.thinking_open = details.open; setThinkingOpen(details.open); });
          details.appendChild(summary);
          details.appendChild(thinkPre);
          bubble.appendChild(details);
        }
        const pre = document.createElement('pre');
        pre.textContent = m.content || '';
        bubble.appendChild(pre);
        item.appendChild(avatar);
        item.appendChild(bubble);
        list.appendChild(item);
      });
      list.scrollTop = list.scrollHeight;
    }

    async function checkHealth() {
      const label = document.getElementById('healthlabel');
      const dot = document.getElementById('healthdot');
      try {
        const r = await fetch('/api/health');
        if (r.ok) {
          if (dot) { dot.classList.add('ok'); dot.classList.remove('err'); }
          label.textContent = 'Backend: Healthy';
        } else {
          if (dot) { dot.classList.add('err'); dot.classList.remove('ok'); }
          label.textContent = 'Backend: Error';
        }
      } catch {
        if (dot) { dot.classList.add('err'); dot.classList.remove('ok'); }
        label.textContent = 'Backend: Offline';
      }
    }

    async function sendMessage() {
      const ta = document.getElementById('input');
      const text = ta.value.trim();
      if (!text) return;
      ta.value = '';
      addMessage('user', text);

      // Determine reasoning-effort setting and whether to show thinking UI
      const effortSel = document.getElementById('effort');
      const effort = effortSel && effortSel.value ? effortSel.value : 'medium';

      // Prepare an assistant placeholder we can stream into
      const placeholder = { role: 'assistant', content: '', thinking: '', thinking_enabled: effort !== 'off', thinking_open: thinkingOpenPref };
      messages.push(placeholder);
      renderMessages();

      // Send only user/system/tool messages; UI assistant placeholder is local-only
      let messagesToSend = messages.filter(m => m && (m.role === 'user' || m.role === 'system' || m.role === 'tool'));
      // If Effort is Off, prepend a developer hint to suppress reasoning (works on some models)
      if (effort === 'off') {
        messagesToSend = [
          { role: 'developer', content: '# Juice: 0 !important' },
          ...messagesToSend,
        ];
      }
      const sessionId = ensureSessionId();
      const body = { messages: messagesToSend, session_id: sessionId };
      if (effort && effort !== 'off') {
        body.reasoning = { effort };
      }
      console.log('[Chat] Request body to backend', body);
      try {
        const res = await fetch('/api/v1/chat/completions?debug=1', {
          method: 'POST', headers: { 'Content-Type': 'application/json', 'X-Debug': '1' }, body: JSON.stringify(body)
        });
        if (!res.ok || !res.body) {
          let text = '';
          try { text = await res.text(); } catch {}
          console.error('[Chat] Backend non-ok', res.status, text);
          throw new Error('Upstream error: ' + res.status);
        }
        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          const chunk = decoder.decode(value, { stream: true });
          buffer += chunk;
          let idx;
          while ((idx = buffer.indexOf('\n\n')) !== -1) {
            const block = buffer.slice(0, idx);
            buffer = buffer.slice(idx + 2);
            const linesAll = block.split('\n');
            const eventLine = linesAll.find(l => l.startsWith('event:')) || '';
            const eventType = eventLine ? eventLine.replace(/^event:\s?/, '').trim() : 'message';
            const lines = linesAll.filter(l => l.startsWith('data:')).map(l => l.replace(/^data:\s?/, ''));
            for (const line of lines) {
              if (!line || line === '[DONE]') continue;
              try {
                const json = JSON.parse(line);
                // Log every parsed SSE JSON for debugging
                if (eventType === 'debug') console.log('[Chat][SSE DEBUG]', json);
                else console.log('[Chat][SSE]', json);
                // Surface explicit error frames from server
                if (json && json.error) {
                  const detail = json.detail ? `\nDetail: ${String(json.detail).slice(0, 500)}` : '';
                  placeholder.content += `\n\n[Error] ${json.error}${detail}`;
                  renderMessages();
                  continue;
                }
                const choice = json.choices && json.choices[0];
                if (choice && choice.delta && typeof choice.delta.content === 'string') {
                  placeholder.content += choice.delta.content;
                  renderMessages();
                } else if (choice && choice.message && typeof choice.message.content === 'string') {
                  placeholder.content += choice.message.content;
                  renderMessages();
                } else if (typeof json.content === 'string') {
                  placeholder.content += json.content;
                  renderMessages();
                }

                // Capture reasoning/thinking tokens if present from various providers
                const appendThinking = (val) => {
                  if (!placeholder.thinking_enabled) return;
                  if (typeof val === 'string' && val) {
                    placeholder.thinking += val;
                    renderMessages();
                  }
                };
                if (choice && choice.delta) {
                  appendThinking(choice.delta.reasoning);
                  appendThinking(choice.delta.reasoning_content);
                  appendThinking(choice.delta.thinking);
                }
                if (choice && choice.message) {
                  appendThinking(choice.message.reasoning);
                  appendThinking(choice.message.reasoning_content);
                  appendThinking(choice.message.thinking);
                }
                appendThinking(json.reasoning);
                appendThinking(json.reasoning_content);
                appendThinking(json.thinking);
              } catch (_) { /* ignore non-JSON */ }
            }
          }
        }
        console.log('[Chat] Stream complete. Assistant chars:', (placeholder.content || '').length);
        // If we had a local name for this session but it wasn't saved server-side yet, persist it now
        const desiredName = localNames[sessionId];
        if (desiredName && !((allSessions||[]).some(s => s.session_id === sessionId && s.name === desiredName))) {
          try {
            await fetch(`/api/v1/chat/sessions/${encodeURIComponent(sessionId)}`, {
              method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name: desiredName })
            });
          } catch {}
          // Refresh sessions list
          try { await loadSessions(); } catch {}
        }
        renderMessages();
      } catch (e) {
        console.error('[Chat] Streaming error', e);
        placeholder.content += `\n\n[Error] ${e.message || e}`;
        renderMessages();
      }
    }

    function handleKey(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    }

    function clearChat() {
      messages = [];
      renderMessages();
    }

    async function loadSessions() {
      const res = await fetch('/api/v1/chat/sessions?limit=200');
      const data = await res.json();
      if (!data.ok) throw new Error(data.error || 'Failed to load sessions');
      allSessions = data.sessions || [];
      renderSessionList();
    }

    function renderSessionList() {
      const list = document.getElementById('sessionList');
      if (!list) return;
      list.innerHTML = '';
      const empty = document.createElement('div');
      if (!allSessions.length) {
        empty.className = 'item';
        empty.style.opacity = '0.8';
        empty.textContent = 'No sessions';
        list.appendChild(empty);
      } else {
        allSessions.forEach(s => {
          const el = document.createElement('div');
          el.className = 'item' + (s.session_id === currentSessionId ? ' active' : '');
          el.onclick = (e) => { if (e.target.closest('.actions')) return; selectSession(s.session_id); };
          const left = document.createElement('div');
          left.style.display = 'flex';
          left.style.flexDirection = 'column';
          const name = document.createElement('div');
          name.className = 'name';
          name.textContent = s.name || s.session_id;
          const meta = document.createElement('div');
          meta.className = 'meta';
          meta.textContent = s.session_id;
          left.appendChild(name);
          left.appendChild(meta);

          const actions = document.createElement('div');
          actions.className = 'actions';
          const rn = document.createElement('a'); rn.href = '#'; rn.textContent = 'Rename'; rn.onclick = (e) => { e.preventDefault(); renameSession(s.session_id); };
          const del = document.createElement('a'); del.href = '#'; del.textContent = 'Delete'; del.style.color = 'var(--danger)'; del.onclick = (e) => { e.preventDefault(); deleteSession(s.session_id); };
          actions.appendChild(rn); actions.appendChild(del);

          el.appendChild(left);
          el.appendChild(actions);
          list.appendChild(el);
        });
      }

      // Render pending new session indicator if current is not in server sessions yet
      if (currentSessionId && !(allSessions || []).some(s => s.session_id === currentSessionId)) {
        const el = document.createElement('div');
        el.className = 'item active';
        const left = document.createElement('div');
        left.style.display = 'flex';
        left.style.flexDirection = 'column';
        const nm = document.createElement('div'); nm.className = 'name'; nm.textContent = nameFor(currentSessionId) || 'New chat';
        const mt = document.createElement('div'); mt.className = 'meta'; mt.textContent = `${currentSessionId} (unsent)`;
        left.appendChild(nm); left.appendChild(mt);
        const actions = document.createElement('div'); actions.className = 'actions';
        const rn = document.createElement('a'); rn.href = '#'; rn.textContent = 'Rename'; rn.onclick = (e)=>{ e.preventDefault(); renameSession(currentSessionId); };
        const del = document.createElement('a'); del.href = '#'; del.textContent = 'Discard'; del.style.color = 'var(--danger)'; del.onclick = (e)=>{ e.preventDefault(); discardCurrentSession(); };
        actions.appendChild(rn); actions.appendChild(del);
        el.appendChild(left); el.appendChild(actions);
        list.prepend(el);
      }
    }

    function discardCurrentSession() {
      // Remove local name, clear messages, and unset current session ID
      if (currentSessionId && localNames[currentSessionId]) { delete localNames[currentSessionId]; saveLocalNames(); }
      setCurrentSessionId(null);
      messages = [];
      renderMessages();
    }

    function updateSessionLabel() {
      const el = document.getElementById('currSessionLabel');
      if (!el) return;
      const id = currentSessionId;
      if (!id) { el.textContent = 'New chat'; return; }
      const nm = nameFor(id);
      el.textContent = nm ? `${nm}` : id;
    }

    async function selectSession(id) {
      setCurrentSessionId(id);
      await loadLogsForSession(id).catch(() => {});
    }

    async function loadLogsForSession(id) {
      isLoadingLogs = true;
      try {
        const res = await fetch(`/api/v1/chat/logs?session_id=${encodeURIComponent(id)}&order=asc&limit=500`);
        const data = await res.json();
        if (!data.ok) throw new Error(data.error || 'Failed to load logs');
        const logs = data.logs || [];
        messages = [];
        logs.forEach(l => {
          if (l.direction === 'request' && typeof l.content === 'string' && l.content) {
            messages.push({ role: 'user', content: l.content });
          } else if (l.direction === 'response' && typeof l.content === 'string') {
            const thinking = l && l.meta && typeof l.meta.thinking === 'string' ? l.meta.thinking : '';
            messages.push({ role: 'assistant', content: l.content, thinking, thinking_enabled: !!thinking, thinking_open: thinkingOpenPref });
          }
        });
        renderMessages();
      } finally {
        isLoadingLogs = false;
      }
    }

    async function renameSession(id) {
      const curr = nameFor(id) || '';
      const val = prompt('Enter a name for this session:', curr);
      if (val === null) return;
      const name = String(val).trim();
      if (!name) { delete localNames[id]; saveLocalNames(); try { await saveServerName(id, null); } catch {} renderSessionList(); updateSessionLabel(); return; }
      localNames[id] = name; saveLocalNames();
      // If this session exists on the server already, persist now; otherwise defer until first send
      if ((allSessions||[]).some(s => s.session_id === id)) {
        try { await saveServerName(id, name); await loadSessions(); } catch {}
      }
      renderSessionList();
      updateSessionLabel();
    }

    async function saveServerName(id, name) {
      return fetch(`/api/v1/chat/sessions/${encodeURIComponent(id)}`, {
        method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name })
      }).then(r => r.ok ? r.json() : r.text().then(t => { throw new Error(t||'Failed to save name'); }));
    }

    async function deleteSession(id) {
      if (!confirm('Delete this session and all its messages?')) return;
      try {
        await fetch(`/api/v1/chat/sessions/${encodeURIComponent(id)}`, { method: 'DELETE' });
      } catch {}
      if (currentSessionId === id) {
        // Move to a fresh session
        setCurrentSessionId(null);
        messages = [];
        renderMessages();
      }
      try { await loadSessions(); } catch {}
    }

    function newSession() {
      // Set a new ID but do not touch the server until first send
      const id = (self.crypto?.randomUUID?.() || Math.random().toString(36).slice(2));
      setCurrentSessionId(id);
      messages = [];
      renderMessages();
    }

    window.addEventListener('load', () => {
      checkHealth();
      setInterval(checkHealth, 5000);
      updateTime();
      setInterval(updateTime, 1000);
      // Load sessions list and choose starting state
      loadSessions().catch(() => {});
      updateSessionLabel();
      // Restore sidebar state
      const openPref = (() => { try { return JSON.parse(localStorage.getItem(sidebarOpenKey) || 'true'); } catch { return true; } })();
      setSidebarOpen(!!openPref);
    });

    function setSidebarOpen(open) {
      const layout = document.getElementById('layout');
      if (!layout) return;
      if (open) layout.classList.remove('sidebar-collapsed');
      else layout.classList.add('sidebar-collapsed');
      try { localStorage.setItem(sidebarOpenKey, JSON.stringify(!!open)); } catch {}
    }

    function toggleSidebar() {
      const layout = document.getElementById('layout');
      if (!layout) return;
      const isCollapsed = layout.classList.contains('sidebar-collapsed');
      setSidebarOpen(isCollapsed);
    }
  </script>
</head>
<body>
  <header>
    <div class="nav">
      <div>
        <a href="/">← Back</a>
      </div>
      <div class="status">
        <span id="timeText"></span>
        <span class="sep">|</span>
        <span class="dot" id="healthdot"></span>
        <span id="healthlabel">Checking...</span>
      </div>
    </div>
  </header>
  <div class="wrap">
    <div style="padding: 8px 16px; display:flex; align-items:center; gap:8px; justify-content:space-between;">
      <button class="toggle-btn" onclick="toggleSidebar()">☰ Sessions</button>
      <div class="toolbar" style="margin:0;">
        <span>Session: <code style="opacity:0.9"><span id="currSessionLabel"></span></code></span>
      </div>
    </div>
    <div class="layout sidebar-collapsed" id="layout">
      <aside class="sidebar">
        <div class="head">
          <button onclick="newSession()">+ New Session</button>
        </div>
        <div class="list" id="sessionList"></div>
      </aside>
      <main class="content">
        <div class="messages" id="messages"></div>
      </main>
    </div>
  </div>
  <div class="composer">
    <div class="inner">
      <textarea id="input" placeholder="Ask anything..." rows="1" onkeydown="handleKey(event)"></textarea>
      <div style="display:flex; flex-direction:column; gap:6px; align-items:flex-end; min-width: 120px;">
        <button onclick="sendMessage()">Send ↵</button>
        <div class="toolbar">
          <label for="effort" style="font-size:12px; color:var(--muted)">Effort</label>
          <select id="effort" style="background: transparent; color: var(--text); border: 1px solid rgba(255,255,255,0.15); border-radius: 8px; padding: 4px 6px;">
            <option value="off">Off</option>
            <option value="low">Low</option>
            <option value="medium" selected>Medium</option>
            <option value="high">High</option>
          </select>
          <a class="link" href="#" onclick="clearChat(); return false;">Clear</a>
      </div>
      </div>
    </div>
  </div>
</body>
</html>

